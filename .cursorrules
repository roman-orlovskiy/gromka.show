Используй nuxt 4
Читай документацию по nuxt и nuxt ui и сохрани куда-то себе актуальные данные уже
Базовые компоненты из @nuxt/ui 4.1.0 https://ui.nuxt.com/docs/components
Глобальные настройки в stores/settings.ts

В компонентах использовать scss и БЭМ вида block__element--modifier
.block {
  &__element {
    &--modifier {
      ...
    }
  }
}

Вычисляемые свойства использовать через computed
Классы с условиями выносить в отдельные переменные computed

Сложные повторяющиеся вычисления в utils
Хуки в composables

Не предлагай запустить npm run dev или npm run build, я сам это делаю
Все относящееся к приложению в app/ Не в корне проекта

Не используй UFormGroup, это nuxt ui 2, а мы используем nuxt ui 4
Глобальную логику выноси в stores

На кнопки UButton всегда добавлять класс cursor-pointer
Для логики используй DRY KISS SOLID PRINCIPLES

<UAlert 
  v-if="profileSuccess" 
  color="green"
Нельзя использовать цвета вроде green, red и т п
Цвета для компонент обычно "error" | "primary" | "secondary" | "success" | "info" | "warning" | "neutral"

Читай документацию по компонентам и используй их правильно https://ui.nuxt.com/docs/components

Используй DRY, не копируй код

После изменения схемы базы данных предлагай команды для миграции базы данных
Для миграции базы данных используй команды в package.json (При необходимости добавляй новые команды)

Файлы раскидывай по папкам согласно логике приложения. Используй кебаб-кейс для названий папок и файлов.

1) Разделяй команды для dev и prod
- `prisma migrate dev` — ТОЛЬКО локально/в dev: генерирует новые миграции и применяет их.
- `prisma migrate deploy` — ТОЛЬКО на проде/в CI: применяет УЖЕ существующие миграции, новые НЕ создаёт.

2) Всегда генерируй миграции только через prisma migrate dev
Не пиши SQL-миграции руками “по месту” и не переименовывай папки миграций.
Prisma сам создаёт папку вида YYYYMMDDHHMMSS_name — так порядок всегда корректный.
Пример (локально, в dev окружении):
docker compose exec app npx prisma migrate dev --name add_runner_game_settings

3) Никогда не “задним числом” не меняй даты/имена миграций
То, что у тебя миграции с январём 2025, а таблица создаётся только в декабре 2025 — это обычно следствие:
ручного переименования папок,
или добавления “старой” миграции после того, как база уже жила.
Правило: появилась новая правка схемы → новая миграция в конец, без переименований старых.

4) Перед пушем всегда тестируй миграции как на “пустом проде”
Ключевой тест: развернуть БД с нуля и прогнать `prisma migrate deploy`, а не только `migrate dev`.
Локально (в докер-окружении), максимально похоже на прод:
поднять чистую БД (с новым volume/без данных),
запустить `npx prisma migrate deploy` (или твой npm run db:migrate),
убедиться, что всё применилось с нуля.

5) Не редактируй старые миграции после того, как они ушли на прод
Если миграция уже применена где-то в реальной среде — не правь её, делай новую “фиксирующую” миграцию в конец.

6) Не предлагай “чинить” прод через ручные правки таблицы `_prisma_migrations`
На проде вместо этого используй `prisma migrate resolve` (и только если понимаешь последствия).
Ручной `DELETE/UPDATE` в `_prisma_migrations` — крайняя аварийная мера, только если нет других вариантов и есть бэкап.

7) Если есть миграции с датами, идущими раньше создания таблиц (по порядку),
делай их replay-safe:
используй DO $$ ... IF EXISTS(...) THEN ... END IF; $$, чтобы shadow DB
и пустая БД проходили без ошибок.
Это важно для `prisma migrate dev` и `prisma migrate deploy` на чистой базе.

8) После любых миграций в docker окружении всегда делай prisma generate
в контейнере (или используй скрипт, который делает migrate+generate),
иначе Prisma Client может не знать о новых полях.

9) После миграций в docker окружении перезапускай app контейнер,
иначе запущенный сервер может продолжать использовать старый Prisma Client.